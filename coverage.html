
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>markit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/khicago/markit/ast.go (100.0%)</option>
				
				<option value="file1">github.com/khicago/markit/core_protocol.go (100.0%)</option>
				
				<option value="file2">github.com/khicago/markit/lexer.go (100.0%)</option>
				
				<option value="file3">github.com/khicago/markit/parser.go (96.1%)</option>
				
				<option value="file4">github.com/khicago/markit/protocol.go (100.0%)</option>
				
				<option value="file5">github.com/khicago/markit/token.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package markit provides an extensible markup language parser with pluggable
// tag bracket protocols for parsing various markup languages and custom formats.
//
// MarkIt is designed around the concept of configurable tag bracket protocols,
// allowing users to define custom markup syntaxes through plugins. Instead of
// being tied to specific markup languages like XML or HTML, MarkIt provides
// a flexible foundation where any tag-based syntax can be supported through
// protocol extensions.
//
// Core Design Philosophy:
//   - Tag Bracket Protocols: Define custom syntax like &lt;a...b&gt; where 'a' and 'b'
//     are configurable opening and closing bracket sequences
//   - Plugin Architecture: Load syntax plugins at parser initialization
//   - Language Agnostic: Support XML, HTML, and any custom markup through plugins
//   - Compile-time Configuration: Case sensitivity and other options configurable
//
// Key Features:
// - ğŸ”§ Pluggable tag bracket protocols (&lt;...&gt;, &lt;?...?&gt;, &lt;!...&gt;, etc.)
// - ğŸ¯ Universal syntax support (XML, HTML, custom formats)
// - âš¡ High-performance parsing with minimal overhead
// - ğŸ“ Precise error reporting with position tracking
// - ğŸ”€ Visitor pattern for flexible AST traversal
// - ğŸ§© Plugin system for extending syntax support
package markit

// Node è¡¨ç¤º AST ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹
type Node interface {
        // Type è¿”å›èŠ‚ç‚¹ç±»å‹
        Type() NodeType
        // Position è¿”å›èŠ‚ç‚¹åœ¨æºç ä¸­çš„ä½ç½®
        Position() Position
        // String è¿”å›èŠ‚ç‚¹çš„å­—ç¬¦ä¸²è¡¨ç¤º
        String() string
}

// NodeType è¡¨ç¤ºèŠ‚ç‚¹ç±»å‹
type NodeType int

const (
        NodeTypeDocument NodeType = iota
        NodeTypeElement
        NodeTypeText
        NodeTypeProcessingInstruction
        NodeTypeDoctype
        NodeTypeCDATA
        NodeTypeComment
)

// Document è¡¨ç¤ºæ–‡æ¡£æ ¹èŠ‚ç‚¹
type Document struct {
        Children []Node
        Pos      Position
}

func (d *Document) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeDocument }</span>
func (d *Document) Position() Position <span class="cov8" title="1">{ return d.Pos }</span>
func (d *Document) String() string     <span class="cov8" title="1">{ return "Document" }</span>

// Element è¡¨ç¤ºå…ƒç´ èŠ‚ç‚¹
type Element struct {
        TagName    string
        Attributes map[string]string
        Children   []Node
        SelfClose  bool
        Pos        Position
}

func (e *Element) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeElement }</span>
func (e *Element) Position() Position <span class="cov8" title="1">{ return e.Pos }</span>
func (e *Element) String() string     <span class="cov8" title="1">{ return e.TagName }</span>

// Text è¡¨ç¤ºæ–‡æœ¬èŠ‚ç‚¹
type Text struct {
        Content string
        Pos     Position
}

func (t *Text) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeText }</span>
func (t *Text) Position() Position <span class="cov8" title="1">{ return t.Pos }</span>
func (t *Text) String() string     <span class="cov8" title="1">{ return t.Content }</span>

// ProcessingInstruction è¡¨ç¤ºå¤„ç†æŒ‡ä»¤èŠ‚ç‚¹
type ProcessingInstruction struct {
        Target  string
        Content string
        Pos     Position
}

func (pi *ProcessingInstruction) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeProcessingInstruction }</span>
func (pi *ProcessingInstruction) Position() Position <span class="cov8" title="1">{ return pi.Pos }</span>
func (pi *ProcessingInstruction) String() string     <span class="cov8" title="1">{ return pi.Target }</span>

// Doctype è¡¨ç¤ºDOCTYPEå£°æ˜èŠ‚ç‚¹
type Doctype struct {
        Content string
        Pos     Position
}

func (dt *Doctype) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeDoctype }</span>
func (dt *Doctype) Position() Position <span class="cov8" title="1">{ return dt.Pos }</span>
func (dt *Doctype) String() string     <span class="cov8" title="1">{ return dt.Content }</span>

// CDATA è¡¨ç¤ºCDATAèŠ‚ç‚¹
type CDATA struct {
        Content string
        Pos     Position
}

func (cd *CDATA) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeCDATA }</span>
func (cd *CDATA) Position() Position <span class="cov8" title="1">{ return cd.Pos }</span>
func (cd *CDATA) String() string     <span class="cov8" title="1">{ return cd.Content }</span>

// Comment è¡¨ç¤ºæ³¨é‡ŠèŠ‚ç‚¹
type Comment struct {
        Content string
        Pos     Position
}

func (c *Comment) Type() NodeType     <span class="cov8" title="1">{ return NodeTypeComment }</span>
func (c *Comment) Position() Position <span class="cov8" title="1">{ return c.Pos }</span>
func (c *Comment) String() string     <span class="cov8" title="1">{ return c.Content }</span>

// AttributeProcessor å±æ€§å¤„ç†å™¨æ¥å£
type AttributeProcessor interface {
        // ProcessAttribute å¤„ç†å±æ€§ï¼Œè¿”å›å¤„ç†åçš„é”®å€¼å¯¹
        ProcessAttribute(key, value string) (string, interface{}, error)
        // IsBooleanAttribute æ£€æŸ¥æ˜¯å¦æ˜¯å¸ƒå°”å±æ€§
        IsBooleanAttribute(key string) bool
}

// DefaultAttributeProcessor é»˜è®¤å±æ€§å¤„ç†å™¨
type DefaultAttributeProcessor struct{}

func (p *DefaultAttributeProcessor) ProcessAttribute(key, value string) (string, interface{}, error) <span class="cov8" title="1">{
        // å¦‚æœå€¼ä¸ºç©ºï¼Œè®¤ä¸ºæ˜¯å¸ƒå°”å±æ€§
        if value == "" </span><span class="cov8" title="1">{
                return key, true, nil
        }</span>
        <span class="cov8" title="1">return key, value, nil</span>
}

func (p *DefaultAttributeProcessor) IsBooleanAttribute(key string) bool <span class="cov8" title="1">{
        // HTML5 æ ‡å‡†å¸ƒå°”å±æ€§åˆ—è¡¨
        booleanAttrs := map[string]bool{
                "checked":   true,
                "disabled":  true,
                "selected":  true,
                "readonly":  true,
                "required":  true,
                "autofocus": true,
                "autoplay":  true,
                "controls":  true,
                "defer":     true,
                "hidden":    true,
                "loop":      true,
                "multiple":  true,
                "muted":     true,
                "open":      true,
                "reversed":  true,
                "scoped":    true,
        }
        return booleanAttrs[key]
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package markit

// CoreProtocol MarkIt æ ¸å¿ƒåè®®å®šä¹‰
// è¿™äº›æ˜¯ MarkIt çš„å†…ç½®åè®®ï¼Œä¸èƒ½è¢«è¦†ç›–æˆ–ç§»é™¤
type CoreProtocol struct {
        Name        string
        OpenSeq     string
        CloseSeq    string
        SelfClose   string
        TokenType   TokenType
        Description string
}

// GetCoreProtocols è¿”å› MarkIt çš„æ ¸å¿ƒåè®®
// è¿™äº›åè®®æ˜¯å†…ç½®çš„ï¼Œä¸éœ€è¦æ³¨å†Œï¼Œä¹Ÿä¸èƒ½è¢«è¦†ç›–
func GetCoreProtocols() []CoreProtocol <span class="cov8" title="1">{
        return []CoreProtocol{
                {
                        Name:        "markit-standard-tag",
                        OpenSeq:     "&lt;",
                        CloseSeq:    "&gt;",
                        SelfClose:   "/",
                        TokenType:   TokenOpenTag,
                        Description: "MarkIt standard tags &lt;tag&gt;",
                },
                {
                        Name:        "markit-comment",
                        OpenSeq:     "&lt;!--",
                        CloseSeq:    "--&gt;",
                        SelfClose:   "",
                        TokenType:   TokenComment,
                        Description: "MarkIt comments &lt;!-- --&gt;",
                },
        }
}</span>

// CoreProtocolMatcher MarkIt æ ¸å¿ƒåè®®åŒ¹é…å™¨
type CoreProtocolMatcher struct {
        protocols []CoreProtocol
        maxLen    int
}

// NewCoreProtocolMatcher åˆ›å»ºæ ¸å¿ƒåè®®åŒ¹é…å™¨
func NewCoreProtocolMatcher() *CoreProtocolMatcher <span class="cov8" title="1">{
        protocols := GetCoreProtocols()
        matcher := &amp;CoreProtocolMatcher{
                protocols: protocols,
                maxLen:    0,
        }

        // è®¡ç®—æœ€å¤§é•¿åº¦
        for _, protocol := range protocols </span><span class="cov8" title="1">{
                if len(protocol.OpenSeq) &gt; matcher.maxLen </span><span class="cov8" title="1">{
                        matcher.maxLen = len(protocol.OpenSeq)
                }</span>
        }

        <span class="cov8" title="1">return matcher</span>
}

// MatchProtocol åŒ¹é…æ ¸å¿ƒåè®®
func (cpm *CoreProtocolMatcher) MatchProtocol(input string, pos int) *CoreProtocol <span class="cov8" title="1">{
        // æŒ‰å¼€å§‹åºåˆ—é•¿åº¦ä»é•¿åˆ°çŸ­åŒ¹é…ï¼Œç¡®ä¿æœ€é•¿åŒ¹é…ä¼˜å…ˆ
        for length := cpm.maxLen; length &gt;= 1; length-- </span><span class="cov8" title="1">{
                if pos+length &gt; len(input) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">candidate := input[pos : pos+length]
                for i := range cpm.protocols </span><span class="cov8" title="1">{
                        if cpm.protocols[i].OpenSeq == candidate </span><span class="cov8" title="1">{
                                return &amp;cpm.protocols[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package markit

import (
        "fmt"
        "strings"
        "unicode"
        "unicode/utf8"
)

// Lexer è¯æ³•åˆ†æå™¨
type Lexer struct {
        input    string
        position int
        line     int
        column   int
        current  rune
        config   *ParserConfig
}

// NewLexer åˆ›å»ºæ–°çš„è¯æ³•åˆ†æå™¨ï¼ˆä½¿ç”¨é»˜è®¤é…ç½®ï¼‰
func NewLexer(input string) *Lexer <span class="cov8" title="1">{
        return NewLexerWithConfig(input, DefaultConfig())
}</span>

// NewLexerWithConfig åˆ›å»ºå¸¦é…ç½®çš„è¯æ³•åˆ†æå™¨
func NewLexerWithConfig(input string, config *ParserConfig) *Lexer <span class="cov8" title="1">{
        l := &amp;Lexer{
                input:  input,
                line:   1,
                column: 0,
                config: config,
        }
        l.readChar()
        return l
}</span>

// SetConfig è®¾ç½®è¯æ³•åˆ†æå™¨é…ç½®
func (l *Lexer) SetConfig(config *ParserConfig) <span class="cov8" title="1">{
        l.config = config
}</span>

// GetConfig è·å–è¯æ³•åˆ†æå™¨é…ç½®
func (l *Lexer) GetConfig() *ParserConfig <span class="cov8" title="1">{
        return l.config
}</span>

// NextToken è·å–ä¸‹ä¸€ä¸ª token
func (l *Lexer) NextToken() Token <span class="cov8" title="1">{
        l.skipWhitespace()

        pos := Position{
                Line:   l.line,
                Column: l.column,
                Offset: l.position,
        }

        if l.position &gt;= len(l.input) </span><span class="cov8" title="1">{
                return Token{Type: TokenEOF, Value: "", Position: pos}
        }</span>

        // è®¡ç®—å½“å‰å­—ç¬¦çš„ä½ç½®ï¼ˆå› ä¸º readChar å·²ç»ç§»åŠ¨äº†ä½ç½®ï¼‰
        <span class="cov8" title="1">currentPos := l.position
        if l.current != 0 </span><span class="cov8" title="1">{
                // å›é€€åˆ°å½“å‰å­—ç¬¦çš„ä½ç½®
                _, size := utf8.DecodeRuneInString(l.input[l.position-1:])
                currentPos = l.position - size
        }</span>

        // ä½¿ç”¨æ ¸å¿ƒåè®®åŒ¹é…å™¨æ£€æŸ¥æ˜¯å¦æ˜¯æ ‡ç­¾å¼€å§‹
        <span class="cov8" title="1">if protocol := l.config.CoreMatcher.MatchProtocol(l.input, currentPos); protocol != nil </span><span class="cov8" title="1">{
                return l.readProtocolToken(protocol)
        }</span>

        // è¯»å–æ–‡æœ¬å†…å®¹
        <span class="cov8" title="1">token := l.readText(pos)
        return token</span>
}

// readChar è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦
func (l *Lexer) readChar() <span class="cov8" title="1">{
        if l.position &gt;= len(l.input) </span><span class="cov8" title="1">{
                l.current = 0 // EOF
        }</span> else<span class="cov8" title="1"> {
                if l.current == '\n' </span><span class="cov8" title="1">{
                        l.line++
                        l.column = 0
                }</span>
                // æ­£ç¡®è§£ç UTF-8å­—ç¬¦
                <span class="cov8" title="1">r, size := utf8.DecodeRuneInString(l.input[l.position:])
                l.current = r
                l.position += size
                l.column++</span>
        }
}

// peekChar æŸ¥çœ‹ä¸‹ä¸€ä¸ªå­—ç¬¦ä½†ä¸ç§»åŠ¨ä½ç½®
func (l *Lexer) peekChar() rune <span class="cov8" title="1">{
        if l.position &gt;= len(l.input) </span><span class="cov8" title="1">{
                return 0
        }</span>
        // æ­£ç¡®è§£ç UTF-8å­—ç¬¦
        <span class="cov8" title="1">r, _ := utf8.DecodeRuneInString(l.input[l.position:])
        return r</span>
}

// skipWhitespace è·³è¿‡ç©ºç™½å­—ç¬¦
func (l *Lexer) skipWhitespace() <span class="cov8" title="1">{
        for unicode.IsSpace(l.current) </span><span class="cov8" title="1">{
                l.readChar()
        }</span>
}

// readText è¯»å–æ–‡æœ¬å†…å®¹
func (l *Lexer) readText(pos Position) Token <span class="cov8" title="1">{
        var text strings.Builder

        for l.current != '&lt;' &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                text.WriteRune(l.current)
                l.readChar()
        }</span>

        <span class="cov8" title="1">content := strings.TrimSpace(text.String())

        return Token{
                Type:     TokenText,
                Value:    content,
                Position: pos,
        }</span>
}

// readIdentifier è¯»å–æ ‡è¯†ç¬¦ï¼ˆæ ‡ç­¾åæˆ–å±æ€§åï¼‰
func (l *Lexer) readIdentifier() string <span class="cov8" title="1">{
        var identifier strings.Builder

        // ç¬¬ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯å­—æ¯ã€ä¸‹åˆ’çº¿æˆ–è¿å­—ç¬¦
        if !isIdentifierStart(l.current) </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">for isIdentifierChar(l.current) </span><span class="cov8" title="1">{
                identifier.WriteRune(l.current)
                l.readChar()
        }</span>

        <span class="cov8" title="1">return identifier.String()</span>
}

// readAttribute è¯»å–å±æ€§
func (l *Lexer) readAttribute() (string, string, error) <span class="cov8" title="1">{
        // è¯»å–å±æ€§å
        name := l.readIdentifier()
        if name == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid attribute name")
        }</span>

        <span class="cov8" title="1">l.skipWhitespace()

        // æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å·
        if l.current != '=' </span><span class="cov8" title="1">{
                // å¸ƒå°”å±æ€§ï¼Œæ²¡æœ‰å€¼
                return name, "", nil
        }</span>

        <span class="cov8" title="1">l.readChar() // è·³è¿‡ '='
        l.skipWhitespace()

        // è¯»å–å±æ€§å€¼
        value, err := l.readAttributeValue()
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return name, value, nil</span>
}

// readAttributeValue è¯»å–å±æ€§å€¼
func (l *Lexer) readAttributeValue() (string, error) <span class="cov8" title="1">{
        if l.current == '"' || l.current == '\'' </span><span class="cov8" title="1">{
                // å¸¦å¼•å·çš„å€¼
                quote := l.current
                l.readChar() // è·³è¿‡å¼€å§‹å¼•å·

                var value strings.Builder
                for l.current != quote &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                        if l.current == '\\' </span><span class="cov8" title="1">{
                                l.readChar()
                                if l.current != 0 </span><span class="cov8" title="1">{
                                        value.WriteRune(l.current)
                                        l.readChar()
                                }</span>
                        } else<span class="cov8" title="1"> {
                                value.WriteRune(l.current)
                                l.readChar()
                        }</span>
                }

                <span class="cov8" title="1">if l.current != quote </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("unterminated quoted string")
                }</span>
                <span class="cov8" title="1">l.readChar() // è·³è¿‡ç»“æŸå¼•å·

                return value.String(), nil</span>
        } else<span class="cov8" title="1"> {
                // ä¸å¸¦å¼•å·çš„å€¼
                var value strings.Builder
                for !unicode.IsSpace(l.current) &amp;&amp; l.current != '&gt;' &amp;&amp; l.current != '/' &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                        value.WriteRune(l.current)
                        l.readChar()
                }</span>
                <span class="cov8" title="1">return value.String(), nil</span>
        }
}

// isIdentifierStart æ£€æŸ¥å­—ç¬¦æ˜¯å¦å¯ä»¥ä½œä¸ºæ ‡è¯†ç¬¦çš„å¼€å§‹
func isIdentifierStart(r rune) bool <span class="cov8" title="1">{
        return unicode.IsLetter(r) || r == '_' || r == '-' || r == ':'
}</span>

// isIdentifierChar æ£€æŸ¥å­—ç¬¦æ˜¯å¦å¯ä»¥ä½œä¸ºæ ‡è¯†ç¬¦çš„ä¸€éƒ¨åˆ†
func isIdentifierChar(r rune) bool <span class="cov8" title="1">{
        return unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' || r == '-' || r == ':'
}</span>

// readComment è¯»å– XML æ³¨é‡Š &lt;!-- ... --&gt;
func (l *Lexer) readComment(pos Position) Token <span class="cov8" title="1">{
        // è·³è¿‡ "&lt;!--" åºåˆ—ï¼ˆå·²ç»è¢«åè®®åŒ¹é…å™¨è¯†åˆ«ï¼‰
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{ // "&lt;!--" é•¿åº¦ä¸º4
                l.readChar()
        }</span>

        <span class="cov8" title="1">var comment strings.Builder

        // è¯»å–æ³¨é‡Šå†…å®¹ç›´åˆ°æ‰¾åˆ° --&gt;
        for l.current != 0 </span><span class="cov8" title="1">{
                if l.current == '-' &amp;&amp; l.peekChar() == '-' </span><span class="cov8" title="1">{
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ³¨é‡Šç»“æŸ
                        l.readChar() // è·³è¿‡ç¬¬ä¸€ä¸ª '-'
                        if l.current == '-' &amp;&amp; l.peekChar() == '&gt;' </span><span class="cov8" title="1">{
                                l.readChar() // è·³è¿‡ç¬¬äºŒä¸ª '-'
                                l.readChar() // è·³è¿‡ '&gt;'
                                break</span>
                        } else<span class="cov8" title="1"> {
                                // ä¸æ˜¯æ³¨é‡Šç»“æŸï¼Œå°† '-' æ·»åŠ åˆ°å†…å®¹ä¸­
                                comment.WriteRune('-')
                        }</span>
                } else<span class="cov8" title="1"> {
                        comment.WriteRune(l.current)
                        l.readChar()
                }</span>
        }

        <span class="cov8" title="1">return Token{
                Type:     TokenComment,
                Value:    strings.TrimSpace(comment.String()), // å»é™¤å‰åç©ºæ ¼
                Position: pos,
        }</span>
}

// readProtocolToken è¯»å–åè®®token
func (l *Lexer) readProtocolToken(protocol *CoreProtocol) Token <span class="cov8" title="1">{
        pos := Position{
                Line:   l.line,
                Column: l.column,
                Offset: l.position,
        }

        if protocol.Name == "markit-standard-tag" </span><span class="cov8" title="1">{
                return l.readTag(pos)
        }</span> else<span class="cov8" title="1"> if protocol.Name == "markit-comment" </span><span class="cov8" title="1">{
                return l.readComment(pos)
        }</span>

        // å¯¹äºå…¶ä»–åè®®ï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘
        <span class="cov8" title="1">start := l.position
        if l.current != 0 </span><span class="cov8" title="1">{
                _, size := utf8.DecodeRuneInString(l.input[l.position-1:])
                start = l.position - size
        }</span>

        // è·³è¿‡å¼€å§‹åºåˆ—
        <span class="cov8" title="1">for i := 0; i &lt; len(protocol.OpenSeq); i++ </span><span class="cov8" title="1">{
                l.readChar()
        }</span>

        // æŸ¥æ‰¾ç»“æŸåºåˆ—
        <span class="cov8" title="1">closeSeq := protocol.CloseSeq
        for l.position &lt; len(l.input) </span><span class="cov8" title="1">{
                if strings.HasPrefix(l.input[l.position:], closeSeq) </span><span class="cov8" title="1">{
                        content := l.input[start : l.position+len(closeSeq)]
                        // è·³è¿‡ç»“æŸåºåˆ—
                        for i := 0; i &lt; len(closeSeq); i++ </span><span class="cov8" title="1">{
                                l.readChar()
                        }</span>
                        <span class="cov8" title="1">return Token{Type: protocol.TokenType, Value: content, Position: pos}</span>
                }
                <span class="cov8" title="1">l.readChar()</span>
        }

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç»“æŸåºåˆ—ï¼Œè¿”å›åˆ°æ–‡ä»¶æœ«å°¾
        <span class="cov8" title="1">content := l.input[start:]
        return Token{Type: protocol.TokenType, Value: content, Position: pos}</span>
}

// readTag è¯»å–æ ‡ç­¾
func (l *Lexer) readTag(pos Position) Token <span class="cov8" title="1">{
        l.readChar() // è·³è¿‡ '&lt;'

        // æ£€æŸ¥æ˜¯å¦æ˜¯ç»“æŸæ ‡ç­¾
        isCloseTag := false
        if l.current == '/' </span><span class="cov8" title="1">{
                isCloseTag = true
                l.readChar() // è·³è¿‡ '/'
        }</span>

        // è¯»å–æ ‡ç­¾å
        <span class="cov8" title="1">tagName := l.readIdentifier()
        if tagName == "" </span><span class="cov8" title="1">{
                return Token{Type: TokenError, Value: "invalid tag name", Position: pos}
        }</span>

        // è·³è¿‡ç©ºç™½
        <span class="cov8" title="1">l.skipWhitespace()

        // è¯»å–å±æ€§
        attributes := make(map[string]string)
        if !isCloseTag </span><span class="cov8" title="1">{
                for l.current != '&gt;' &amp;&amp; l.current != '/' &amp;&amp; l.current != 0 </span><span class="cov8" title="1">{
                        name, value, err := l.readAttribute()
                        if err != nil </span><span class="cov8" title="1">{
                                return Token{Type: TokenError, Value: err.Error(), Position: pos}
                        }</span>
                        <span class="cov8" title="1">attributes[name] = value
                        l.skipWhitespace()</span>
                }
        }

        // æ£€æŸ¥è‡ªå°é—­æ ‡ç­¾
        <span class="cov8" title="1">isSelfClose := false
        if l.current == '/' </span><span class="cov8" title="1">{
                // æ£€æŸ¥é…ç½®æ˜¯å¦å…è®¸è‡ªå°é—­æ ‡ç­¾
                if l.config != nil &amp;&amp; l.config.AllowSelfCloseTags </span><span class="cov8" title="1">{
                        isSelfClose = true
                        l.readChar() // è·³è¿‡ '/'
                }</span> else<span class="cov8" title="1"> {
                        // å¦‚æœä¸å…è®¸è‡ªå°é—­æ ‡ç­¾ï¼Œå°† '/' è§†ä¸ºæ™®é€šå­—ç¬¦
                        // è¿™é‡Œå¯ä»¥é€‰æ‹©æŠ¥é”™æˆ–è€…ç»§ç»­å¤„ç†
                        return Token{Type: TokenError, Value: "self-closing tags not allowed", Position: pos}
                }</span>
        }

        // è·³è¿‡ '&gt;'
        <span class="cov8" title="1">if l.current != '&gt;' </span><span class="cov8" title="1">{
                return Token{Type: TokenError, Value: "expected '&gt;'", Position: pos}
        }</span>
        <span class="cov8" title="1">l.readChar()

        // ç¡®å®štokenç±»å‹
        var tokenType TokenType
        if isCloseTag </span><span class="cov8" title="1">{
                tokenType = TokenCloseTag
        }</span> else<span class="cov8" title="1"> if isSelfClose </span><span class="cov8" title="1">{
                tokenType = TokenSelfCloseTag
        }</span> else<span class="cov8" title="1"> {
                tokenType = TokenOpenTag
        }</span>

        <span class="cov8" title="1">return Token{
                Type:       tokenType,
                Value:      tagName,
                Attributes: attributes,
                Position:   pos,
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package markit

import (
        "fmt"
        "strings"
)

// Parser è¯­æ³•åˆ†æå™¨
type Parser struct {
        lexer     *Lexer
        current   Token
        peek      Token
        processor AttributeProcessor
        config    *ParserConfig
}

// NewParser åˆ›å»ºæ–°çš„è¯­æ³•åˆ†æå™¨ï¼ˆä½¿ç”¨é»˜è®¤é…ç½®ï¼‰
func NewParser(input string) *Parser <span class="cov8" title="1">{
        return NewParserWithConfig(input, DefaultConfig())
}</span>

// NewParserWithConfig åˆ›å»ºå¸¦é…ç½®çš„è¯­æ³•åˆ†æå™¨
func NewParserWithConfig(input string, config *ParserConfig) *Parser <span class="cov8" title="1">{
        lexer := NewLexerWithConfig(input, config)
        p := &amp;Parser{
                lexer:     lexer,
                processor: config.AttributeProcessor,
                config:    config,
        }

        // è¯»å–å‰ä¸¤ä¸ª tokenï¼Œè·³è¿‡æ³¨é‡Š
        p.nextToken()
        p.nextToken()

        // å¦‚æœé…ç½®è¦æ±‚è·³è¿‡æ³¨é‡Šï¼Œåˆ™è·³è¿‡å®ƒä»¬
        if p.config.SkipComments </span><span class="cov8" title="1">{
                for p.current.Type == TokenComment </span><span class="cov8" title="1">{
                        p.nextToken()
                }</span>
        }

        <span class="cov8" title="1">return p</span>
}

// SetAttributeProcessor è®¾ç½®å±æ€§å¤„ç†å™¨
func (p *Parser) SetAttributeProcessor(processor AttributeProcessor) <span class="cov8" title="1">{
        p.processor = processor
        p.config.AttributeProcessor = processor
}</span>

// GetConfig è·å–è§£æå™¨é…ç½®
func (p *Parser) GetConfig() *ParserConfig <span class="cov8" title="1">{
        return p.config
}</span>

// SetConfig è®¾ç½®è§£æå™¨é…ç½®
func (p *Parser) SetConfig(config *ParserConfig) <span class="cov8" title="1">{
        p.config = config
        p.processor = config.AttributeProcessor
        // æ›´æ–°lexeré…ç½®
        p.lexer.SetConfig(config)
}</span>

// Parse è§£æè¾“å…¥å¹¶è¿”å› AST
func (p *Parser) Parse() (*Document, error) <span class="cov8" title="1">{
        doc := &amp;Document{
                Children: []Node{},
                Pos:      p.current.Position,
        }

        for p.current.Type != TokenEOF </span><span class="cov8" title="1">{
                node, err := p.parseNode()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if node != nil </span><span class="cov8" title="1">{
                        doc.Children = append(doc.Children, node)
                }</span>
        }

        <span class="cov8" title="1">return doc, nil</span>
}

// parseNode è§£æä¸€ä¸ªèŠ‚ç‚¹
func (p *Parser) parseNode() (Node, error) <span class="cov8" title="1">{
        // å¦‚æœé…ç½®è¦æ±‚è·³è¿‡æ³¨é‡Šï¼Œåˆ™è·³è¿‡æ³¨é‡Štoken
        if p.config.SkipComments &amp;&amp; p.current.Type == TokenComment </span><span class="cov8" title="1">{
                p.nextToken()
                return p.parseNode() // é€’å½’è§£æä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }</span>

        <span class="cov8" title="1">switch p.current.Type </span>{
        case TokenText:<span class="cov8" title="1">
                return p.parseText()</span>
        case TokenOpenTag:<span class="cov8" title="1">
                return p.parseElement()</span>
        case TokenSelfCloseTag:<span class="cov8" title="1">
                return p.parseSelfCloseElement()</span>
        case TokenProcessingInstruction:<span class="cov0" title="0">
                return p.parseProcessingInstruction()</span>
        case TokenDoctype:<span class="cov0" title="0">
                return p.parseDoctype()</span>
        case TokenCDATA:<span class="cov0" title="0">
                return p.parseCDATA()</span>
        case TokenComment:<span class="cov8" title="1">
                return p.parseComment()</span>
        case TokenError:<span class="cov8" title="1">
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  p.current.Value,
                }</span>
        case TokenEOF:<span class="cov8" title="1">
                return nil, nil</span>
        default:<span class="cov8" title="1">
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("unexpected token %s", p.current.Type),
                }</span>
        }
}

// parseText è§£ææ–‡æœ¬èŠ‚ç‚¹
func (p *Parser) parseText() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenText </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected text token, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">text := &amp;Text{
                Content: p.current.Value,
                Pos:     p.current.Position,
        }

        p.nextToken()
        return text, nil</span>
}

// parseElement è§£æå…ƒç´ èŠ‚ç‚¹
func (p *Parser) parseElement() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenOpenTag </span><span class="cov0" title="0">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected open tag, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">element := &amp;Element{
                TagName:    p.current.Value,
                Attributes: p.current.Attributes,
                Children:   []Node{},
                SelfClose:  false,
                Pos:        p.current.Position,
        }

        tagName := p.current.Value
        p.nextToken()

        // è§£æå­èŠ‚ç‚¹
        for p.current.Type != TokenCloseTag &amp;&amp; p.current.Type != TokenEOF </span><span class="cov8" title="1">{
                child, err := p.parseNode()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if child != nil </span><span class="cov8" title="1">{
                        element.Children = append(element.Children, child)
                }</span>
        }

        // æ£€æŸ¥ç»“æŸæ ‡ç­¾
        <span class="cov8" title="1">if p.current.Type != TokenCloseTag </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected close tag for &lt;%s&gt;, got %s", tagName, p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">if p.current.Value != tagName </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("mismatched tags: expected &lt;/%s&gt;, got &lt;/%s&gt;", tagName, p.current.Value),
                }
        }</span>

        <span class="cov8" title="1">p.nextToken()
        return element, nil</span>
}

// parseSelfCloseElement è§£æè‡ªé—­åˆå…ƒç´ 
func (p *Parser) parseSelfCloseElement() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenSelfCloseTag </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected self-close tag, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">element := &amp;Element{
                TagName:    p.current.Value,
                Attributes: p.current.Attributes,
                Children:   []Node{},
                SelfClose:  true,
                Pos:        p.current.Position,
        }

        p.nextToken()
        return element, nil</span>
}

// parseProcessingInstruction è§£æå¤„ç†æŒ‡ä»¤
func (p *Parser) parseProcessingInstruction() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenProcessingInstruction </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected processing instruction token, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">pi := &amp;ProcessingInstruction{
                Target:  p.current.Value,
                Content: p.current.Value,
                Pos:     p.current.Position,
        }

        p.nextToken()
        return pi, nil</span>
}

// parseDoctype è§£æDOCTYPEå£°æ˜
func (p *Parser) parseDoctype() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenDoctype </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected doctype token, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">doctype := &amp;Doctype{
                Content: p.current.Value,
                Pos:     p.current.Position,
        }

        p.nextToken()
        return doctype, nil</span>
}

// parseCDATA è§£æCDATAèŠ‚ç‚¹
func (p *Parser) parseCDATA() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenCDATA </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected CDATA token, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">cdata := &amp;CDATA{
                Content: p.current.Value,
                Pos:     p.current.Position,
        }

        p.nextToken()
        return cdata, nil</span>
}

// parseComment è§£ææ³¨é‡ŠèŠ‚ç‚¹
func (p *Parser) parseComment() (Node, error) <span class="cov8" title="1">{
        if p.current.Type != TokenComment </span><span class="cov8" title="1">{
                return nil, &amp;ParseError{
                        Position: p.current.Position,
                        Message:  fmt.Sprintf("expected comment token, got %s", p.current.Type),
                }
        }</span>

        <span class="cov8" title="1">comment := &amp;Comment{
                Content: p.current.Value,
                Pos:     p.current.Position,
        }

        p.nextToken()
        return comment, nil</span>
}

// nextToken ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª token
func (p *Parser) nextToken() <span class="cov8" title="1">{
        p.current = p.peek
        p.peek = p.lexer.NextToken()

        // ä¸åœ¨è¿™é‡Œè·³è¿‡æ³¨é‡Šï¼Œè®©parseNodeå¤„ç†
}</span>

// ParseError è§£æé”™è¯¯
type ParseError struct {
        Position Position
        Message  string
}

func (e *ParseError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("parse error at %s: %s", e.Position, e.Message)
}</span>

// Visitor è®¿é—®è€…æ¥å£ï¼Œç”¨äºéå† AST
type Visitor interface {
        VisitDocument(*Document) error
        VisitElement(*Element) error
        VisitText(*Text) error
        VisitProcessingInstruction(*ProcessingInstruction) error
        VisitDoctype(*Doctype) error
        VisitCDATA(*CDATA) error
        VisitComment(*Comment) error
}

// Walk éå† AST
func Walk(node Node, visitor Visitor) error <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *Document:<span class="cov8" title="1">
                if err := visitor.VisitDocument(n); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, child := range n.Children </span><span class="cov8" title="1">{
                        if err := Walk(child, visitor); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        case *Element:<span class="cov8" title="1">
                if err := visitor.VisitElement(n); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, child := range n.Children </span><span class="cov8" title="1">{
                        if err := Walk(child, visitor); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        case *Text:<span class="cov8" title="1">
                return visitor.VisitText(n)</span>
        case *ProcessingInstruction:<span class="cov8" title="1">
                return visitor.VisitProcessingInstruction(n)</span>
        case *Doctype:<span class="cov8" title="1">
                return visitor.VisitDoctype(n)</span>
        case *CDATA:<span class="cov8" title="1">
                return visitor.VisitCDATA(n)</span>
        case *Comment:<span class="cov8" title="1">
                return visitor.VisitComment(n)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// PrettyPrint ç¾åŒ–æ‰“å° AST
func PrettyPrint(node Node) string <span class="cov8" title="1">{
        var sb strings.Builder
        prettyPrintNode(node, &amp;sb, 0)
        return sb.String()
}</span>

func prettyPrintNode(node Node, sb *strings.Builder, indent int) <span class="cov8" title="1">{
        indentStr := strings.Repeat("  ", indent)

        switch n := node.(type) </span>{
        case *Document:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sDocument\n", indentStr))
                for _, child := range n.Children </span><span class="cov8" title="1">{
                        prettyPrintNode(child, sb, indent+1)
                }</span>
        case *Element:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%s&lt;%s", indentStr, n.TagName))
                for key, value := range n.Attributes </span><span class="cov8" title="1">{
                        if value == "" </span><span class="cov8" title="1">{
                                sb.WriteString(fmt.Sprintf(" %s", key))
                        }</span> else<span class="cov8" title="1"> {
                                sb.WriteString(fmt.Sprintf(" %s=%q", key, value))
                        }</span>
                }
                <span class="cov8" title="1">if n.SelfClose </span><span class="cov8" title="1">{
                        sb.WriteString(" /&gt;\n")
                }</span> else<span class="cov8" title="1"> {
                        sb.WriteString("&gt;\n")
                        for _, child := range n.Children </span><span class="cov8" title="1">{
                                prettyPrintNode(child, sb, indent+1)
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s&lt;/%s&gt;\n", indentStr, n.TagName))</span>
                }
        case *Text:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sText: %q\n", indentStr, n.Content))</span>
        case *ProcessingInstruction:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sPI: %q\n", indentStr, n.Content))</span>
        case *Doctype:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sDoctype: %q\n", indentStr, n.Content))</span>
        case *CDATA:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sCDATA: %q\n", indentStr, n.Content))</span>
        case *Comment:<span class="cov8" title="1">
                sb.WriteString(fmt.Sprintf("%sComment: %q\n", indentStr, n.Content))</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package markit

import (
        "strings"
)

// ParserConfig è§£æå™¨é…ç½®
type ParserConfig struct {
        // å¤§å°å†™æ•æ„Ÿæ€§é…ç½®
        CaseSensitive bool

        // æ ¸å¿ƒåè®®åŒ¹é…å™¨ï¼ˆå†…ç½®ï¼Œä¸å¯ä¿®æ”¹ï¼‰
        CoreMatcher *CoreProtocolMatcher

        // å±æ€§å¤„ç†å™¨
        AttributeProcessor AttributeProcessor

        // å…¶ä»–é…ç½®é€‰é¡¹
        TrimWhitespace     bool
        SkipComments       bool
        AllowEmptyElements bool
        AllowSelfCloseTags bool // æ˜¯å¦å…è®¸è‡ªå°é—­æ ‡ç­¾
}

// DefaultConfig åˆ›å»ºé»˜è®¤é…ç½®
func DefaultConfig() *ParserConfig <span class="cov8" title="1">{
        config := &amp;ParserConfig{
                CaseSensitive:      true,
                CoreMatcher:        NewCoreProtocolMatcher(),
                AttributeProcessor: &amp;DefaultAttributeProcessor{},
                TrimWhitespace:     true,
                SkipComments:       false,
                AllowEmptyElements: true,
                AllowSelfCloseTags: true, // é»˜è®¤å…è®¸è‡ªå°é—­æ ‡ç­¾
        }

        return config
}</span>

// NormalizeCase æ ¹æ®é…ç½®æ ‡å‡†åŒ–å¤§å°å†™
func (config *ParserConfig) NormalizeCase(s string) string <span class="cov8" title="1">{
        if !config.CaseSensitive </span><span class="cov8" title="1">{
                return strings.ToLower(s)
        }</span>
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package markit

import "fmt"

// TokenType è¡¨ç¤ºæ ‡è®°ç±»å‹
type TokenType int

const (
        TokenError TokenType = iota
        TokenEOF
        TokenText
        TokenOpenTag
        TokenCloseTag
        TokenSelfCloseTag
        TokenAttribute
        TokenComment
        // æ–°å¢çš„åè®®ç±»å‹
        TokenProcessingInstruction
        TokenDoctype
        TokenCDATA
        TokenEntity
)

// String è¿”å› TokenType çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (t TokenType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TokenError:<span class="cov8" title="1">
                return "ERROR"</span>
        case TokenEOF:<span class="cov8" title="1">
                return "EOF"</span>
        case TokenText:<span class="cov8" title="1">
                return "TEXT"</span>
        case TokenOpenTag:<span class="cov8" title="1">
                return "OPEN_TAG"</span>
        case TokenCloseTag:<span class="cov8" title="1">
                return "CLOSE_TAG"</span>
        case TokenSelfCloseTag:<span class="cov8" title="1">
                return "SELF_CLOSE_TAG"</span>
        case TokenAttribute:<span class="cov8" title="1">
                return "ATTRIBUTE"</span>
        case TokenComment:<span class="cov8" title="1">
                return "COMMENT"</span>
        case TokenProcessingInstruction:<span class="cov8" title="1">
                return "PROCESSING_INSTRUCTION"</span>
        case TokenDoctype:<span class="cov8" title="1">
                return "DOCTYPE"</span>
        case TokenCDATA:<span class="cov8" title="1">
                return "CDATA"</span>
        case TokenEntity:<span class="cov8" title="1">
                return "ENTITY"</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("UNKNOWN(%d)", int(t))</span>
        }
}

// Token è¡¨ç¤ºä¸€ä¸ªè¯æ³•æ ‡è®°
type Token struct {
        Type       TokenType
        Value      string
        Attributes map[string]string
        Position   Position
}

// Position è¡¨ç¤ºæºç ä¸­çš„ä½ç½®ä¿¡æ¯
type Position struct {
        Line   int
        Column int
        Offset int
}

// String è¿”å› Token çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (t Token) String() string <span class="cov8" title="1">{
        switch t.Type </span>{
        case TokenError:<span class="cov8" title="1">
                return fmt.Sprintf("ERROR(%s)", t.Value)</span>
        case TokenEOF:<span class="cov8" title="1">
                return "EOF"</span>
        case TokenText:<span class="cov8" title="1">
                return fmt.Sprintf("TEXT(%q)", t.Value)</span>
        case TokenOpenTag:<span class="cov8" title="1">
                return fmt.Sprintf("OPEN_TAG(%s)", t.Value)</span>
        case TokenCloseTag:<span class="cov8" title="1">
                return fmt.Sprintf("CLOSE_TAG(%s)", t.Value)</span>
        case TokenSelfCloseTag:<span class="cov8" title="1">
                return fmt.Sprintf("SELF_CLOSE_TAG(%s)", t.Value)</span>
        case TokenAttribute:<span class="cov8" title="1">
                return fmt.Sprintf("ATTR(%s)", t.Value)</span>
        case TokenComment:<span class="cov8" title="1">
                return fmt.Sprintf("COMMENT(%s)", t.Value)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("UNKNOWN(%d)", int(t.Type))</span>
        }
}

// String è¿”å› Position çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (p Position) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d:%d", p.Line, p.Column)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
